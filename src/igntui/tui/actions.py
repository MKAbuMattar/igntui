#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import curses
import json
import logging
import time
from pathlib import Path
from typing import Optional

from .. import __version__, get_version_string
from ..ui import ConfirmDialog, ExportDialog, HelpDialog, SaveDialog

logger = logging.getLogger(__name__)


class TUIActions:
    def __init__(self, stdscr, state):
        self.stdscr = stdscr
        self.state = state

    def save_gitignore(self) -> None:
        if not self.state.generated_content or self.state.generated_content.startswith(
            "# No templates selected"
        ):
            self.state.set_status_message(
                "No content to save - select templates first", is_error=True
            )
            return

        try:
            dialog = SaveDialog(self.stdscr)
            save_path_str = dialog.show()

            if not save_path_str:
                self.state.set_status_message("Save cancelled")
                return

            gitignore_path = Path(save_path_str)

            if gitignore_path.exists():
                confirm_dialog = ConfirmDialog(
                    self.stdscr,
                    "Overwrite File?",
                    f"File '{gitignore_path.name}' already exists. Overwrite?",
                )
                if not confirm_dialog.show():
                    self.state.set_status_message("Save cancelled")
                    return

            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            selected_list = self.state.get_selected_templates_list()
            templates_str = ", ".join(selected_list)

            header = f"""# .gitignore file generated by igntui (MKAbuMattar.com)
# Generated on: {timestamp}
# Templates used: {templates_str}
#
# This file was created using the igntui tool
# Visit: https://github.com/MKAbuMattar/igntui
#
# ================================================================

"""

            content_with_header = header + self.state.generated_content

            with open(gitignore_path, "w", encoding="utf-8") as f:
                f.write(content_with_header)

            content_size = len(self.state.generated_content)
            self.state.set_status_message(
                f"✓ Saved to {gitignore_path.name} ({content_size} chars)"
            )
            logger.info(f"Saved {content_size} chars to {gitignore_path}")

        except Exception as e:
            self.state.set_status_message(f"Failed to save: {e}", is_error=True)
            logger.error(f"Error saving .gitignore: {e}")

    def export_templates(self) -> None:
        if not self.state.selected_templates:
            self.state.set_status_message(
                "No templates selected for export", is_error=True
            )
            return

        try:
            dialog = ExportDialog(self.stdscr)
            export_path_str = dialog.show()

            if not export_path_str:
                self.state.set_status_message("Export cancelled")
                return

            export_path = Path(export_path_str)

            export_data = {
                "export_info": {
                    "tool": "igntui",
                    "version": f"{__version__}",
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "templates_count": len(self.state.selected_templates),
                },
                "templates": self.state.get_selected_templates_list(),
                "search_info": {
                    "last_search": self.state.filter_text,
                    "search_mode": self.state.current_search_mode,
                    "total_available": len(self.state.templates),
                    "filtered_count": len(self.state.filtered_templates),
                },
            }

            with open(export_path, "w", encoding="utf-8") as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)

            self.state.set_status_message(
                f"✓ Exported {len(self.state.selected_templates)} templates to {export_path.name}"
            )
            logger.info(
                f"Exported {len(self.state.selected_templates)} templates to {export_path}"
            )

        except Exception as e:
            self.state.set_status_message(f"Export failed: {e}", is_error=True)
            logger.error(f"Error exporting templates: {e}")

    def show_help_dialog(self) -> None:
        try:
            dialog = HelpDialog(self.stdscr)
            dialog.show()

            self.stdscr.clear()
            self.stdscr.refresh()

        except Exception as e:
            self.state.set_status_message(f"Error showing help: {e}", is_error=True)
            logger.error(f"Error showing help dialog: {e}")

    def show_info_dialog(self) -> None:
        max_y, max_x = self.stdscr.getmaxyx()

        dialog_width = min(70, max_x - 4)
        dialog_height = min(18, max_y - 4)
        dialog_y = (max_y - dialog_height) // 2
        dialog_x = (max_x - dialog_width) // 2

        try:
            version_string = get_version_string()

            for y in range(max_y):
                for x in range(max_x):
                    try:
                        self.stdscr.addch(
                            y, x, " ", curses.color_pair(1) | curses.A_DIM
                        )
                    except curses.error:
                        pass

            for y in range(dialog_y, dialog_y + dialog_height):
                for x in range(dialog_x, dialog_x + dialog_width):
                    try:
                        self.stdscr.addch(y, x, " ", curses.color_pair(8))
                    except curses.error:
                        pass

            self._draw_border(
                dialog_y, dialog_x, dialog_height, dialog_width, "About igntui"
            )

            info_lines = [
                "",
                "igntui - GitIgnore Template Generator",
                "",
                version_string,
                "",
                "A powerful TUI for generating .gitignore files",
                "from gitignore.io templates with smart search,",
                "caching, and multi-template support.",
                "",
                "Author: Mohammad Abu Mattar",
                "GitHub: github.com/MKAbuMattar/igntui",
                "Website: MKAbuMattar.com",
                "",
                "Press any key to close...",
            ]

            for idx, line in enumerate(info_lines):
                y = dialog_y + 2 + idx
                if y < dialog_y + dialog_height - 1:
                    try:
                        x = dialog_x + (dialog_width - len(line)) // 2
                        if "igntui" in line and idx == 1:
                            attr = curses.color_pair(4) | curses.A_BOLD
                        elif line.startswith("igntui/"):
                            attr = curses.color_pair(2) | curses.A_BOLD
                        elif line.startswith("Author:") or line.startswith("GitHub:"):
                            attr = curses.color_pair(6)
                        else:
                            attr = curses.color_pair(8)
                        self.stdscr.addstr(y, x, line, attr)
                    except curses.error:
                        pass

            self.stdscr.refresh()

            self.stdscr.timeout(-1)
            self.stdscr.getch()
            self.stdscr.timeout(100)

            self.stdscr.clear()
            self.stdscr.refresh()

        except Exception as e:
            self.state.set_status_message(f"Error showing info: {e}", is_error=True)
            logger.error(f"Error showing info dialog: {e}")

    def _draw_border(
        self, y: int, x: int, height: int, width: int, title: str = ""
    ) -> None:
        try:
            self.stdscr.addch(y, x, curses.ACS_ULCORNER, curses.color_pair(1))
            self.stdscr.addch(
                y, x + width - 1, curses.ACS_URCORNER, curses.color_pair(1)
            )
            self.stdscr.addch(
                y + height - 1, x, curses.ACS_LLCORNER, curses.color_pair(1)
            )
            self.stdscr.addch(
                y + height - 1, x + width - 1, curses.ACS_LRCORNER, curses.color_pair(1)
            )

            for i in range(1, width - 1):
                self.stdscr.addch(y, x + i, curses.ACS_HLINE, curses.color_pair(1))
                self.stdscr.addch(
                    y + height - 1, x + i, curses.ACS_HLINE, curses.color_pair(1)
                )

            for i in range(1, height - 1):
                self.stdscr.addch(y + i, x, curses.ACS_VLINE, curses.color_pair(1))
                self.stdscr.addch(
                    y + i, x + width - 1, curses.ACS_VLINE, curses.color_pair(1)
                )

            if title:
                title_text = f" {title} "
                title_x = x + (width - len(title_text)) // 2
                self.stdscr.addstr(
                    y, title_x, title_text, curses.color_pair(6) | curses.A_BOLD
                )

        except curses.error:
            pass
